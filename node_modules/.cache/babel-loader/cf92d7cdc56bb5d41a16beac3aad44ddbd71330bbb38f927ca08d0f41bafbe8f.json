{"ast":null,"code":"import { MathUtils } from \"three\";\nimport { setPerf, getPerf } from \"./store.mjs\";\nconst overLimitFps = {\n  value: 0,\n  fpsLimit: 60,\n  isOverLimit: 0\n};\nconst average = arr => (arr == null ? void 0 : arr.reduce((a, b) => a + b, 0)) / arr.length;\nclass GLPerf {\n  constructor() {\n    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.names = [\"\"];\n    this.finished = [];\n    this.paused = false;\n    this.overClock = false;\n    this.queryHasResult = false;\n    this.queryCreated = false;\n    this.isWebGL2 = true;\n    this.memAccums = [];\n    this.gpuAccums = [];\n    this.activeAccums = [];\n    this.logsAccums = {\n      mem: [],\n      gpu: [],\n      cpu: [],\n      fps: [],\n      fpsFixed: []\n    };\n    this.fpsChart = [];\n    this.gpuChart = [];\n    this.cpuChart = [];\n    this.memChart = [];\n    this.paramLogger = () => {};\n    this.glFinish = () => {};\n    this.chartLogger = () => {};\n    this.chartLen = 60;\n    this.logsPerSecond = 10;\n    this.maxMemory = 1500;\n    this.chartHz = 10;\n    this.startCpuProfiling = false;\n    this.lastCalculateFixed = 0;\n    this.chartFrame = 0;\n    this.gpuTimeProcess = 0;\n    this.chartTime = 0;\n    this.activeQueries = 0;\n    this.circularId = 0;\n    this.detected = 0;\n    this.frameId = 0;\n    this.rafId = 0;\n    this.idleCbId = 0;\n    this.checkQueryId = 0;\n    this.uuid = void 0;\n    this.currentCpu = 0;\n    this.currentMem = 0;\n    this.paramFrame = 0;\n    this.paramTime = 0;\n    this.now = () => {};\n    this.t0 = 0;\n    window.GLPerf = window.GLPerf || {};\n    Object.assign(this, settings);\n    this.fpsChart = new Array(this.chartLen).fill(0);\n    this.gpuChart = new Array(this.chartLen).fill(0);\n    this.cpuChart = new Array(this.chartLen).fill(0);\n    this.memChart = new Array(this.chartLen).fill(0);\n    this.now = () => window.performance && window.performance.now ? window.performance.now() : Date.now();\n    this.initGpu();\n    this.is120hz();\n  }\n  initGpu() {\n    this.uuid = MathUtils.generateUUID();\n    if (this.gl) {\n      this.isWebGL2 = true;\n      if (!this.extension) {\n        this.extension = this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\");\n      }\n      if (this.extension === null) {\n        this.isWebGL2 = false;\n      }\n    }\n  }\n  /**\n   * 120hz device detection\n   */\n  is120hz() {\n    let n = 0;\n    const loop = t => {\n      if (++n < 20) {\n        this.rafId = window.requestAnimationFrame(loop);\n      } else {\n        this.detected = Math.ceil(1e3 * n / (t - this.t0) / 70);\n        window.cancelAnimationFrame(this.rafId);\n      }\n      if (!this.t0) this.t0 = t;\n    };\n    this.rafId = window.requestAnimationFrame(loop);\n  }\n  /**\n   * Explicit UI add\n   * @param { string | undefined } name\n   */\n  addUI(name) {\n    if (this.names.indexOf(name) === -1) {\n      this.names.push(name);\n      this.gpuAccums.push(0);\n      this.activeAccums.push(false);\n    }\n  }\n  nextFps(d) {\n    const goal = 1e3 / 60;\n    const elapsed = goal - d.timeRemaining();\n    const fps = goal * overLimitFps.fpsLimit / 10 / elapsed;\n    if (fps < 0) return;\n    overLimitFps.value = fps;\n    if (overLimitFps.isOverLimit < 25) {\n      overLimitFps.isOverLimit++;\n    } else {\n      setPerf({\n        overclockingFps: true\n      });\n    }\n  }\n  /**\n   * Increase frameID\n   * @param { any | undefined } now\n   */\n  nextFrame(now) {\n    this.frameId++;\n    const t = now || this.now();\n    let duration = t - this.paramTime;\n    let gpu = 0;\n    if (this.frameId <= 1) {\n      this.paramFrame = this.frameId;\n      this.paramTime = t;\n    } else {\n      if (t >= this.paramTime) {\n        this.maxMemory = window.performance.memory ? window.performance.memory.jsHeapSizeLimit / 1048576 : 0;\n        const frameCount = this.frameId - this.paramFrame;\n        const fpsFixed = frameCount * 1e3 / duration;\n        const fps = getPerf().overclockingFps ? overLimitFps.value : fpsFixed;\n        gpu = this.isWebGL2 ? this.gpuAccums[0] : this.gpuAccums[0] / duration;\n        if (this.isWebGL2) {\n          this.gpuAccums[0] = 0;\n        } else {\n          Promise.all(this.finished).then(() => {\n            this.gpuAccums[0] = 0;\n            this.finished = [];\n          });\n        }\n        this.currentMem = Math.round(window.performance && window.performance.memory ? window.performance.memory.usedJSHeapSize / 1048576 : 0);\n        if (window.performance && this.startCpuProfiling) {\n          window.performance.mark(\"cpu-finished\");\n          const cpuMeasure = performance.measure(\"cpu-duration\", \"cpu-started\", \"cpu-finished\");\n          this.currentCpu = cpuMeasure.duration;\n          this.logsAccums.cpu.push(this.currentCpu);\n          this.startCpuProfiling = false;\n        }\n        this.logsAccums.mem.push(this.currentMem);\n        this.logsAccums.fpsFixed.push(fpsFixed);\n        this.logsAccums.fps.push(fps);\n        this.logsAccums.gpu.push(gpu);\n        if (this.overClock && typeof window.requestIdleCallback !== \"undefined\") {\n          if (overLimitFps.isOverLimit > 0 && fps > fpsFixed) {\n            overLimitFps.isOverLimit--;\n          } else if (getPerf().overclockingFps) {\n            setPerf({\n              overclockingFps: false\n            });\n          }\n        }\n        if (t >= this.paramTime + 1e3 / this.logsPerSecond) {\n          this.paramLogger({\n            cpu: average(this.logsAccums.cpu),\n            gpu: average(this.logsAccums.gpu),\n            mem: average(this.logsAccums.mem),\n            fps: average(this.logsAccums.fps),\n            duration: Math.round(duration),\n            maxMemory: this.maxMemory,\n            frameCount\n          });\n          this.logsAccums.mem = [];\n          this.logsAccums.fps = [];\n          this.logsAccums.gpu = [];\n          this.logsAccums.cpu = [];\n          this.paramFrame = this.frameId;\n          this.paramTime = t;\n        }\n        if (this.overClock) {\n          if (t - this.lastCalculateFixed >= 2 * 1e3) {\n            this.lastCalculateFixed = now;\n            overLimitFps.fpsLimit = Math.round(average(this.logsAccums.fpsFixed) / 10) * 100;\n            setPerf({\n              fpsLimit: overLimitFps.fpsLimit / 10\n            });\n            this.logsAccums.fpsFixed = [];\n            this.paramFrame = this.frameId;\n            this.paramTime = t;\n          }\n        }\n      }\n    }\n    if (!this.detected || !this.chartFrame) {\n      this.chartFrame = this.frameId;\n      this.chartTime = t;\n      this.circularId = 0;\n    } else {\n      const timespan = t - this.chartTime;\n      let hz = this.chartHz * timespan / 1e3;\n      while (--hz > 0 && this.detected) {\n        const frameCount = this.frameId - this.chartFrame;\n        const fpsFixed = frameCount / timespan * 1e3;\n        const fps = getPerf().overclockingFps ? overLimitFps.value : fpsFixed;\n        this.fpsChart[this.circularId % this.chartLen] = fps;\n        const memS = 1e3 / this.currentMem;\n        const cpuS = this.currentCpu;\n        const gpuS = (this.isWebGL2 ? this.gpuAccums[1] * 2 : Math.round(this.gpuAccums[1] / duration * 100)) + 4;\n        if (gpuS > 0) {\n          this.gpuChart[this.circularId % this.chartLen] = gpuS;\n        }\n        if (cpuS > 0) {\n          this.cpuChart[this.circularId % this.chartLen] = cpuS;\n        }\n        if (memS > 0) {\n          this.memChart[this.circularId % this.chartLen] = memS;\n        }\n        for (let i = 0; i < this.names.length; i++) {\n          this.chartLogger({\n            i,\n            data: {\n              fps: this.fpsChart,\n              gpu: this.gpuChart,\n              cpu: this.cpuChart,\n              mem: this.memChart\n            },\n            circularId: this.circularId\n          });\n        }\n        this.circularId++;\n        this.chartFrame = this.frameId;\n        this.chartTime = t;\n      }\n    }\n  }\n  startGpu() {\n    const gl = this.gl;\n    const ext = this.extension;\n    if (!gl || !ext) return;\n    if (this.isWebGL2) {\n      let available = false;\n      let disjoint, ns;\n      if (this.query) {\n        this.queryHasResult = false;\n        let query = this.query;\n        available = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);\n        disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);\n        if (available && !disjoint) {\n          ns = gl.getQueryParameter(this.query, gl.QUERY_RESULT);\n          const ms = ns * 1e-6;\n          if (available || disjoint) {\n            gl.deleteQuery(this.query);\n            query = null;\n          }\n          if (available && ms > 0) {\n            if (!disjoint) {\n              this.activeAccums.forEach((_active, i) => {\n                this.gpuAccums[i] = ms;\n              });\n            }\n          }\n        }\n      }\n      if (available || !this.query) {\n        this.queryCreated = true;\n        this.query = gl.createQuery();\n        gl.beginQuery(ext.TIME_ELAPSED_EXT, this.query);\n      }\n    }\n  }\n  endGpu() {\n    const ext = this.extension;\n    const gl = this.gl;\n    if (this.isWebGL2 && this.queryCreated && gl.getQuery(ext.TIME_ELAPSED_EXT, gl.CURRENT_QUERY)) {\n      gl.endQuery(ext.TIME_ELAPSED_EXT);\n    }\n  }\n  /**\n   * Begin named measurement\n   * @param { string | undefined } name\n   */\n  begin(name) {\n    this.startGpu();\n    this.updateAccums(name);\n  }\n  /**\n   * End named measure\n   * @param { string | undefined } name\n   */\n  end(name) {\n    this.endGpu();\n    this.updateAccums(name);\n  }\n  updateAccums(name) {\n    let nameId = this.names.indexOf(name);\n    if (nameId === -1) {\n      nameId = this.names.length;\n      this.addUI(name);\n    }\n    const t = this.now();\n    this.activeAccums[nameId] = !this.activeAccums[nameId];\n    this.t0 = t;\n  }\n}\nexport { GLPerf, overLimitFps };","map":{"version":3,"names":["overLimitFps","value","fpsLimit","isOverLimit","average","arr","reduce","a","b","length","GLPerf","constructor","settings","arguments","undefined","names","finished","paused","overClock","queryHasResult","queryCreated","isWebGL2","memAccums","gpuAccums","activeAccums","logsAccums","mem","gpu","cpu","fps","fpsFixed","fpsChart","gpuChart","cpuChart","memChart","paramLogger","glFinish","chartLogger","chartLen","logsPerSecond","maxMemory","chartHz","startCpuProfiling","lastCalculateFixed","chartFrame","gpuTimeProcess","chartTime","activeQueries","circularId","detected","frameId","rafId","idleCbId","checkQueryId","uuid","currentCpu","currentMem","paramFrame","paramTime","now","t0","window","Object","assign","Array","fill","performance","Date","initGpu","is120hz","MathUtils","generateUUID","gl","extension","getExtension","n","loop","t","requestAnimationFrame","Math","ceil","cancelAnimationFrame","addUI","name","indexOf","push","nextFps","d","goal","elapsed","timeRemaining","setPerf","overclockingFps","nextFrame","duration","memory","jsHeapSizeLimit","frameCount","getPerf","Promise","all","then","round","usedJSHeapSize","mark","cpuMeasure","measure","requestIdleCallback","timespan","hz","memS","cpuS","gpuS","i","data","startGpu","ext","available","disjoint","ns","query","getQueryParameter","QUERY_RESULT_AVAILABLE","getParameter","GPU_DISJOINT_EXT","QUERY_RESULT","ms","deleteQuery","forEach","_active","createQuery","beginQuery","TIME_ELAPSED_EXT","endGpu","getQuery","CURRENT_QUERY","endQuery","begin","updateAccums","end","nameId"],"sources":["/home/joshua/Documents/proyectos/proyecto-integrador/reto_clase_4/node_modules/r3f-perf/src/internal.ts"],"sourcesContent":["import { MathUtils } from 'three'\nimport { getPerf, setPerf } from './store'\n\ndeclare global {\n  interface Window {\n    GLPerf: any\n  }\n  interface Performance {\n    memory: any\n  }\n}\n\nexport const overLimitFps = {\n  value: 0,\n  fpsLimit: 60,\n  isOverLimit: 0,\n}\n\ninterface LogsAccums {\n  mem: number[]\n  gpu: number[]\n  cpu: number[]\n  fps: number[]\n  fpsFixed: number[]\n}\n\nconst average = (arr: number[]) => arr?.reduce((a: number, b: number) => a + b, 0) / arr.length\n\nexport class GLPerf {\n  names: string[] = ['']\n  finished: any[] = []\n  gl: any\n  extension: any\n  query: any\n  paused: boolean = false\n  overClock: boolean = false\n  queryHasResult: boolean = false\n  queryCreated: boolean = false\n  isWebGL2: boolean = true\n  memAccums: number[] = []\n  gpuAccums: number[] = []\n  activeAccums: boolean[] = []\n  logsAccums: LogsAccums = {\n    mem: [],\n    gpu: [],\n    cpu: [],\n    fps: [],\n    fpsFixed: [],\n  }\n  fpsChart: number[] = []\n  gpuChart: number[] = []\n  cpuChart: number[] = []\n  memChart: number[] = []\n  paramLogger: any = () => {}\n  glFinish: any = () => {}\n  chartLogger: any = () => {}\n  chartLen: number = 60\n  logsPerSecond: number = 10\n  maxMemory: number = 1500\n  chartHz: number = 10\n  startCpuProfiling: boolean = false\n  lastCalculateFixed: number = 0\n  chartFrame: number = 0\n  gpuTimeProcess: number = 0\n  chartTime: number = 0\n  activeQueries: number = 0\n  circularId: number = 0\n  detected: number = 0\n  frameId: number = 0\n  rafId: number = 0\n  idleCbId: number = 0\n  checkQueryId: number = 0\n  uuid: string | undefined = undefined\n  currentCpu: number = 0\n  currentMem: number = 0\n  paramFrame: number = 0\n  paramTime: number = 0\n  now: any = () => {}\n  t0: number = 0\n\n  constructor(settings: object = {}) {\n    window.GLPerf = window.GLPerf || {}\n\n    Object.assign(this, settings)\n\n    this.fpsChart = new Array(this.chartLen).fill(0)\n    this.gpuChart = new Array(this.chartLen).fill(0)\n    this.cpuChart = new Array(this.chartLen).fill(0)\n    this.memChart = new Array(this.chartLen).fill(0)\n    this.now = () => (window.performance && window.performance.now ? window.performance.now() : Date.now())\n    this.initGpu()\n    this.is120hz()\n  }\n  initGpu() {\n    this.uuid = MathUtils.generateUUID()\n    if (this.gl) {\n      this.isWebGL2 = true\n      if (!this.extension) {\n        this.extension = this.gl.getExtension('EXT_disjoint_timer_query_webgl2')\n      }\n      if (this.extension === null) {\n        this.isWebGL2 = false\n      }\n    }\n  }\n  /**\n   * 120hz device detection\n   */\n  is120hz() {\n    let n = 0\n    const loop = (t: number) => {\n      if (++n < 20) {\n        this.rafId = window.requestAnimationFrame(loop)\n      } else {\n        this.detected = Math.ceil((1e3 * n) / (t - this.t0) / 70)\n        window.cancelAnimationFrame(this.rafId)\n      }\n      if (!this.t0) this.t0 = t\n    }\n    this.rafId = window.requestAnimationFrame(loop)\n  }\n\n  /**\n   * Explicit UI add\n   * @param { string | undefined } name\n   */\n  addUI(name: string) {\n    if (this.names.indexOf(name) === -1) {\n      this.names.push(name)\n      this.gpuAccums.push(0)\n      this.activeAccums.push(false)\n    }\n  }\n\n  nextFps(d: any) {\n    const goal = 1000 / 60\n    const elapsed = goal - d.timeRemaining()\n    const fps = (goal * overLimitFps.fpsLimit) / 10 / elapsed\n    if (fps < 0) return\n\n    overLimitFps.value = fps\n    if (overLimitFps.isOverLimit < 25) {\n      overLimitFps.isOverLimit++\n    } else {\n      setPerf({ overclockingFps: true })\n    }\n  }\n  /**\n   * Increase frameID\n   * @param { any | undefined } now\n   */\n  nextFrame(now: any) {\n    this.frameId++\n    const t = now || this.now()\n    let duration = t - this.paramTime\n    let gpu = 0\n    // params\n    if (this.frameId <= 1) {\n      this.paramFrame = this.frameId\n      this.paramTime = t\n    } else {\n      if (t >= this.paramTime) {\n        this.maxMemory = window.performance.memory ? window.performance.memory.jsHeapSizeLimit / 1048576 : 0\n        const frameCount = this.frameId - this.paramFrame\n        const fpsFixed = (frameCount * 1000) / duration\n        const fps = getPerf().overclockingFps ? overLimitFps.value : fpsFixed\n\n        gpu = this.isWebGL2 ? this.gpuAccums[0] : this.gpuAccums[0] / duration\n\n        if (this.isWebGL2) {\n          this.gpuAccums[0] = 0\n        } else {\n          Promise.all(this.finished).then(() => {\n            this.gpuAccums[0] = 0\n            this.finished = []\n          })\n        }\n\n        this.currentMem = Math.round(\n          window.performance && window.performance.memory ? window.performance.memory.usedJSHeapSize / 1048576 : 0\n        )\n\n        if (window.performance && this.startCpuProfiling) {\n          window.performance.mark('cpu-finished')\n          const cpuMeasure = performance.measure('cpu-duration', 'cpu-started', 'cpu-finished')\n          this.currentCpu = cpuMeasure.duration\n\n          this.logsAccums.cpu.push(this.currentCpu)\n          // make sure the measure has started and ended\n          this.startCpuProfiling = false\n        }\n\n        this.logsAccums.mem.push(this.currentMem)\n        this.logsAccums.fpsFixed.push(fpsFixed)\n        this.logsAccums.fps.push(fps)\n        this.logsAccums.gpu.push(gpu)\n\n        if (this.overClock && typeof window.requestIdleCallback !== 'undefined') {\n          if (overLimitFps.isOverLimit > 0 && fps > fpsFixed) {\n            overLimitFps.isOverLimit--\n          } else if (getPerf().overclockingFps) {\n            setPerf({ overclockingFps: false })\n          }\n        }\n        // TODO 200 to settings\n        if (t >= this.paramTime + 1000 / this.logsPerSecond) {\n          this.paramLogger({\n            cpu: average(this.logsAccums.cpu),\n            gpu: average(this.logsAccums.gpu),\n            mem: average(this.logsAccums.mem),\n            fps: average(this.logsAccums.fps),\n            duration: Math.round(duration),\n            maxMemory: this.maxMemory,\n            frameCount,\n          })\n\n          this.logsAccums.mem = []\n          this.logsAccums.fps = []\n          this.logsAccums.gpu = []\n          this.logsAccums.cpu = []\n\n          this.paramFrame = this.frameId\n          this.paramTime = t\n        }\n\n        if (this.overClock) {\n          // calculate the max framerate every two seconds\n          if (t - this.lastCalculateFixed >= 2 * 1000) {\n            this.lastCalculateFixed = now\n            overLimitFps.fpsLimit = Math.round(average(this.logsAccums.fpsFixed) / 10) * 100\n            setPerf({ fpsLimit: overLimitFps.fpsLimit / 10 })\n            this.logsAccums.fpsFixed = []\n\n            this.paramFrame = this.frameId\n            this.paramTime = t\n          }\n        }\n      }\n    }\n\n    // chart\n    if (!this.detected || !this.chartFrame) {\n      this.chartFrame = this.frameId\n      this.chartTime = t\n      this.circularId = 0\n    } else {\n      const timespan = t - this.chartTime\n      let hz = (this.chartHz * timespan) / 1e3\n      while (--hz > 0 && this.detected) {\n        const frameCount = this.frameId - this.chartFrame\n        const fpsFixed = (frameCount / timespan) * 1e3\n        const fps = getPerf().overclockingFps ? overLimitFps.value : fpsFixed\n        this.fpsChart[this.circularId % this.chartLen] = fps\n        // this.fpsChart[this.circularId % this.chartLen] = ((overLimitFps.isOverLimit > 0 ? overLimitFps.value : fps) / overLimitFps.fpsLimit) * 60;\n        const memS = 1000 / this.currentMem\n        const cpuS = this.currentCpu\n        const gpuS = (this.isWebGL2 ? this.gpuAccums[1] * 2 : Math.round((this.gpuAccums[1] / duration) * 100)) + 4\n        if (gpuS > 0) {\n          this.gpuChart[this.circularId % this.chartLen] = gpuS\n        }\n        if (cpuS > 0) {\n          this.cpuChart[this.circularId % this.chartLen] = cpuS\n        }\n        if (memS > 0) {\n          this.memChart[this.circularId % this.chartLen] = memS\n        }\n        for (let i = 0; i < this.names.length; i++) {\n          this.chartLogger({\n            i,\n            data: {\n              fps: this.fpsChart,\n              gpu: this.gpuChart,\n              cpu: this.cpuChart,\n              mem: this.memChart,\n            },\n            circularId: this.circularId,\n          })\n        }\n        this.circularId++\n        this.chartFrame = this.frameId\n        this.chartTime = t\n      }\n    }\n  }\n\n  startGpu() {\n    const gl = this.gl\n    const ext = this.extension\n\n    if (!gl || !ext) return\n    if (this.isWebGL2) {\n      let available = false\n      let disjoint: any, ns: any\n\n      if (this.query) {\n        this.queryHasResult = false\n        let query = this.query\n        // console.log(gl.getParameter(ext.TIMESTAMP_EXT))\n        available = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)\n        disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT)\n\n        if (available && !disjoint) {\n          ns = gl.getQueryParameter(this.query, gl.QUERY_RESULT)\n          const ms = ns * 1e-6\n\n          if (available || disjoint) {\n            // Clean up the query object.\n            gl.deleteQuery(this.query)\n            // Don't re-enter this polling loop.\n            query = null\n          }\n\n          if (available && ms > 0) {\n            // update the display if it is valid\n            if (!disjoint) {\n              this.activeAccums.forEach((_active: any, i: any) => {\n                this.gpuAccums[i] = ms\n              })\n            }\n          }\n        }\n      }\n\n      if (available || !this.query) {\n        this.queryCreated = true\n        this.query = gl.createQuery()\n\n        gl.beginQuery(ext.TIME_ELAPSED_EXT, this.query)\n      }\n    }\n  }\n\n  endGpu() {\n    // finish the query measurement\n    const ext = this.extension\n    const gl = this.gl\n\n    if (this.isWebGL2 && this.queryCreated && gl.getQuery(ext.TIME_ELAPSED_EXT, gl.CURRENT_QUERY)) {\n      gl.endQuery(ext.TIME_ELAPSED_EXT)\n    }\n  }\n\n  /**\n   * Begin named measurement\n   * @param { string | undefined } name\n   */\n  begin(name: string) {\n    this.startGpu()\n    this.updateAccums(name)\n  }\n\n  /**\n   * End named measure\n   * @param { string | undefined } name\n   */\n  end(name: string) {\n    this.endGpu()\n    this.updateAccums(name)\n  }\n\n  updateAccums(name: string) {\n    let nameId = this.names.indexOf(name)\n    if (nameId === -1) {\n      nameId = this.names.length\n      this.addUI(name)\n    }\n\n    const t = this.now()\n\n    this.activeAccums[nameId] = !this.activeAccums[nameId]\n    this.t0 = t\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}