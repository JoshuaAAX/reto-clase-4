{"ast":null,"code":"const countGeoDrawCalls = programs => {\n  programs.forEach((program, _pkey) => {\n    const {\n      meshes\n    } = program;\n    if (!meshes) {\n      return;\n    }\n    let drawCounts2 = {\n      total: 0,\n      type: \"Triangle\",\n      data: []\n    };\n    Object.keys(meshes).forEach(key => {\n      const mesh = meshes[key];\n      const {\n        geometry,\n        material\n      } = mesh;\n      let index = geometry.index;\n      const position = geometry.attributes.position;\n      if (!position) return;\n      let rangeFactor = 1;\n      if (material.wireframe === true) {\n        rangeFactor = 0;\n      }\n      const dataCount = index !== null ? index.count : position.count;\n      const rangeStart = geometry.drawRange.start * rangeFactor;\n      const rangeCount = geometry.drawRange.count * rangeFactor;\n      const drawStart = rangeStart;\n      const drawEnd = Math.min(dataCount, rangeStart + rangeCount) - 1;\n      let countInstanceRatio = 1;\n      const instanceCount = mesh.count || 1;\n      let type = \"Triangle\";\n      let mostDrawCalls = 0;\n      if (mesh.isMesh) {\n        if (material.wireframe === true) {\n          type = \"Line\";\n          countInstanceRatio = countInstanceRatio / 2;\n        } else {\n          type = \"Triangle\";\n          countInstanceRatio = countInstanceRatio / 3;\n        }\n      } else if (mesh.isLine) {\n        type = \"Line\";\n        if (mesh.isLineSegments) {\n          countInstanceRatio = countInstanceRatio / 2;\n        } else if (mesh.isLineLoop) {\n          countInstanceRatio = countInstanceRatio;\n        } else {\n          countInstanceRatio = countInstanceRatio - 1;\n        }\n      } else if (mesh.isPoints) {\n        type = \"Point\";\n        countInstanceRatio = countInstanceRatio;\n      } else if (mesh.isSprite) {\n        type = \"Triangle\";\n        countInstanceRatio = countInstanceRatio / 3;\n      }\n      const drawCount = Math.round(Math.max(0, drawEnd - drawStart + 1) * (countInstanceRatio * instanceCount));\n      if (drawCount > mostDrawCalls) {\n        mostDrawCalls = drawCount;\n        drawCounts2.type = type;\n      }\n      drawCounts2.total += drawCount;\n      drawCounts2.data.push({\n        drawCount,\n        type\n      });\n      mesh.userData.drawCount = {\n        type,\n        count: drawCount\n      };\n    });\n    program.drawCounts = drawCounts2;\n  });\n};\nexport { countGeoDrawCalls };","map":{"version":3,"names":["countGeoDrawCalls","programs","forEach","program","_pkey","meshes","drawCounts2","total","type","data","Object","keys","key","mesh","geometry","material","index","position","attributes","rangeFactor","wireframe","dataCount","count","rangeStart","drawRange","start","rangeCount","drawStart","drawEnd","Math","min","countInstanceRatio","instanceCount","mostDrawCalls","isMesh","isLine","isLineSegments","isLineLoop","isPoints","isSprite","drawCount","round","max","push","userData","drawCounts"],"sources":["/home/joshua/Documents/proyectos/proyecto-integrador/reto_clase_4/node_modules/r3f-perf/src/helpers/countGeoDrawCalls.ts"],"sourcesContent":["import { drawCounts, ProgramsPerfs } from '../store'\n\nexport const countGeoDrawCalls = (programs: ProgramsPerfs) => {\n  programs.forEach((program, _pkey) => {\n    const { meshes } = program\n    if (!meshes) {\n      return\n    }\n    let drawCounts: drawCounts = {\n      total: 0,\n      type: 'Triangle',\n      data: [],\n    }\n    Object.keys(meshes).forEach((key) => {\n      const mesh: any = meshes[key]\n      const { geometry, material } = mesh\n\n      let index = geometry.index\n      const position = geometry.attributes.position\n\n      if (!position) return\n\n      let rangeFactor = 1\n\n      if (material.wireframe === true) {\n        rangeFactor = 0\n      }\n\n      const dataCount = index !== null ? index.count : position.count\n      const rangeStart = geometry.drawRange.start * rangeFactor\n      const rangeCount = geometry.drawRange.count * rangeFactor\n      const drawStart = rangeStart\n      const drawEnd = Math.min(dataCount, rangeStart + rangeCount) - 1\n      let countInstanceRatio = 1\n      const instanceCount = mesh.count || 1\n      let type = 'Triangle'\n      let mostDrawCalls = 0\n      if (mesh.isMesh) {\n        if (material.wireframe === true) {\n          type = 'Line'\n          countInstanceRatio = countInstanceRatio / 2\n        } else {\n          type = 'Triangle'\n          countInstanceRatio = countInstanceRatio / 3\n        }\n      } else if (mesh.isLine) {\n        type = 'Line'\n        if (mesh.isLineSegments) {\n          countInstanceRatio = countInstanceRatio / 2\n        } else if (mesh.isLineLoop) {\n          countInstanceRatio = countInstanceRatio\n        } else {\n          countInstanceRatio = countInstanceRatio - 1\n        }\n      } else if (mesh.isPoints) {\n        type = 'Point'\n        countInstanceRatio = countInstanceRatio\n      } else if (mesh.isSprite) {\n        type = 'Triangle'\n        countInstanceRatio = countInstanceRatio / 3\n      }\n\n      const drawCount = Math.round(Math.max(0, drawEnd - drawStart + 1) * (countInstanceRatio * instanceCount))\n\n      if (drawCount > mostDrawCalls) {\n        mostDrawCalls = drawCount\n        drawCounts.type = type\n      }\n      drawCounts.total += drawCount\n      drawCounts.data.push({ drawCount, type })\n      mesh.userData.drawCount = {\n        type,\n        count: drawCount,\n      }\n    })\n    program.drawCounts = drawCounts\n  })\n}\n"],"mappings":"AAEa,MAAAA,iBAAA,GAAqBC,QAAA,IAA4B;EACnDA,QAAA,CAAAC,OAAA,CAAQ,CAACC,OAAA,EAASC,KAAA,KAAU;IAC7B;MAAEC;IAAW,IAAAF,OAAA;IACnB,IAAI,CAACE,MAAA,EAAQ;MACX;IACF;IACA,IAAIC,WAAA,GAAyB;MAC3BC,KAAA,EAAO;MACPC,IAAA,EAAM;MACNC,IAAA,EAAM;IAAC;IAETC,MAAA,CAAOC,IAAA,CAAKN,MAAM,EAAEH,OAAA,CAASU,GAAA,IAAQ;MAC7B,MAAAC,IAAA,GAAYR,MAAA,CAAOO,GAAG;MACtB;QAAEE,QAAA;QAAUC;MAAa,IAAAF,IAAA;MAE/B,IAAIG,KAAA,GAAQF,QAAA,CAASE,KAAA;MACf,MAAAC,QAAA,GAAWH,QAAA,CAASI,UAAA,CAAWD,QAAA;MAErC,IAAI,CAACA,QAAA,EAAU;MAEf,IAAIE,WAAA,GAAc;MAEd,IAAAJ,QAAA,CAASK,SAAA,KAAc,MAAM;QACjBD,WAAA;MAChB;MAEA,MAAME,SAAA,GAAYL,KAAA,KAAU,OAAOA,KAAA,CAAMM,KAAA,GAAQL,QAAA,CAASK,KAAA;MACpD,MAAAC,UAAA,GAAaT,QAAA,CAASU,SAAA,CAAUC,KAAA,GAAQN,WAAA;MACxC,MAAAO,UAAA,GAAaZ,QAAA,CAASU,SAAA,CAAUF,KAAA,GAAQH,WAAA;MAC9C,MAAMQ,SAAA,GAAYJ,UAAA;MAClB,MAAMK,OAAA,GAAUC,IAAA,CAAKC,GAAA,CAAIT,SAAA,EAAWE,UAAA,GAAaG,UAAU,IAAI;MAC/D,IAAIK,kBAAA,GAAqB;MACnB,MAAAC,aAAA,GAAgBnB,IAAA,CAAKS,KAAA,IAAS;MACpC,IAAId,IAAA,GAAO;MACX,IAAIyB,aAAA,GAAgB;MACpB,IAAIpB,IAAA,CAAKqB,MAAA,EAAQ;QACX,IAAAnB,QAAA,CAASK,SAAA,KAAc,MAAM;UACxBZ,IAAA;UACPuB,kBAAA,GAAqBA,kBAAA,GAAqB;QAAA,OACrC;UACEvB,IAAA;UACPuB,kBAAA,GAAqBA,kBAAA,GAAqB;QAC5C;MAAA,WACSlB,IAAA,CAAKsB,MAAA,EAAQ;QACf3B,IAAA;QACP,IAAIK,IAAA,CAAKuB,cAAA,EAAgB;UACvBL,kBAAA,GAAqBA,kBAAA,GAAqB;QAAA,WACjClB,IAAA,CAAKwB,UAAA,EAAY;UACLN,kBAAA,GAAAA,kBAAA;QAAA,OAChB;UACLA,kBAAA,GAAqBA,kBAAA,GAAqB;QAC5C;MAAA,WACSlB,IAAA,CAAKyB,QAAA,EAAU;QACjB9B,IAAA;QACcuB,kBAAA,GAAAA,kBAAA;MAAA,WACZlB,IAAA,CAAK0B,QAAA,EAAU;QACjB/B,IAAA;QACPuB,kBAAA,GAAqBA,kBAAA,GAAqB;MAC5C;MAEM,MAAAS,SAAA,GAAYX,IAAA,CAAKY,KAAA,CAAMZ,IAAA,CAAKa,GAAA,CAAI,GAAGd,OAAA,GAAUD,SAAA,GAAY,CAAC,KAAKI,kBAAA,GAAqBC,aAAA,CAAc;MAExG,IAAIQ,SAAA,GAAYP,aAAA,EAAe;QACbA,aAAA,GAAAO,SAAA;QAChBlC,WAAA,CAAWE,IAAA,GAAOA,IAAA;MACpB;MACAF,WAAA,CAAWC,KAAA,IAASiC,SAAA;MACpBlC,WAAA,CAAWG,IAAA,CAAKkC,IAAA,CAAK;QAAEH,SAAA;QAAWhC;MAAM;MACxCK,IAAA,CAAK+B,QAAA,CAASJ,SAAA,GAAY;QACxBhC,IAAA;QACAc,KAAA,EAAOkB;MAAA;IACT,CACD;IACDrC,OAAA,CAAQ0C,UAAA,GAAavC,WAAA;EAAA,CACtB;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}