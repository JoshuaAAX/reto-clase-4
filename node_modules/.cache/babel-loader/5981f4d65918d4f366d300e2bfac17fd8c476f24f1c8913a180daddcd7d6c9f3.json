{"ast":null,"code":"function estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nexport { estimateBytesUsed };","map":{"version":3,"names":["estimateBytesUsed","geometry","mem","name","attributes","attr","getAttribute","count","itemSize","array","BYTES_PER_ELEMENT","indices","getIndex"],"sources":["/home/joshua/Documents/proyectos/proyecto-integrador/reto_clase_4/node_modules/r3f-perf/src/helpers/estimateBytesUsed.ts"],"sourcesContent":["import { BufferGeometry } from \"three\"\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nexport function estimateBytesUsed(geometry: BufferGeometry): number {\n    // Return the estimated memory used by this geometry in bytes\n    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n    // for InterleavedBufferAttributes.\n    let mem = 0\n    for (let name in geometry.attributes) {\n      const attr = geometry.getAttribute(name)\n      mem += attr.count * attr.itemSize * (attr.array as any).BYTES_PER_ELEMENT\n    }\n  \n    const indices = geometry.getIndex()\n    mem += indices ? indices.count * indices.itemSize * (indices.array as any).BYTES_PER_ELEMENT : 0\n    return mem\n}"],"mappings":"AAMO,SAASA,kBAAkBC,QAAA,EAAkC;EAIhE,IAAIC,GAAA,GAAM;EACD,SAAAC,IAAA,IAAQF,QAAA,CAASG,UAAA,EAAY;IAC9B,MAAAC,IAAA,GAAOJ,QAAA,CAASK,YAAA,CAAaH,IAAI;IACvCD,GAAA,IAAOG,IAAA,CAAKE,KAAA,GAAQF,IAAA,CAAKG,QAAA,GAAYH,IAAA,CAAKI,KAAA,CAAcC,iBAAA;EAC1D;EAEM,MAAAC,OAAA,GAAUV,QAAA,CAASW,QAAA;EACzBV,GAAA,IAAOS,OAAA,GAAUA,OAAA,CAAQJ,KAAA,GAAQI,OAAA,CAAQH,QAAA,GAAYG,OAAA,CAAQF,KAAA,CAAcC,iBAAA,GAAoB;EACxF,OAAAR,GAAA;AACX"},"metadata":{},"sourceType":"module","externalDependencies":[]}