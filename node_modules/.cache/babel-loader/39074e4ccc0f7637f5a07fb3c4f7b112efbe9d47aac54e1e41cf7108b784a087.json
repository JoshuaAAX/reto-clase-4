{"ast":null,"code":"import { jsxs, Fragment, jsx } from \"react/jsx-runtime\";\nimport { useMemo, useRef } from \"react\";\nimport { matriceCount, matriceWorldCount } from \"./PerfHeadless.mjs\";\nimport { Graph, Graphpc } from \"../styles.mjs\";\nimport { PauseIcon } from \"@radix-ui/react-icons\";\nimport { useFrame, Canvas } from \"@react-three/fiber\";\nimport \"../index.mjs\";\nimport { colorsGraph } from \"./Perf.mjs\";\nimport * as THREE from \"three\";\nimport { TextsHighHZ } from \"./TextsHighHZ.mjs\";\nimport { getPerf, usePerf } from \"../store.mjs\";\nconst ChartCurve = _ref => {\n  let {\n    colorBlind,\n    minimal,\n    chart = {\n      length: 120,\n      hz: 60\n    }\n  } = _ref;\n  const curves = useMemo(() => {\n    return {\n      fps: new Float32Array(chart.length * 3),\n      cpu: new Float32Array(chart.length * 3),\n      // mem: new Float32Array(chart.length * 3),\n      gpu: new Float32Array(chart.length * 3)\n    };\n  }, [chart]);\n  const fpsRef = useRef(null);\n  const fpsMatRef = useRef(null);\n  const gpuRef = useRef(null);\n  const cpuRef = useRef(null);\n  const dummyVec3 = useMemo(() => new THREE.Vector3(0, 0, 0), []);\n  const updatePoints = function (element) {\n    let factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let ref = arguments.length > 2 ? arguments[2] : undefined;\n    let viewport = arguments.length > 3 ? arguments[3] : undefined;\n    let maxVal = 0;\n    const {\n      width: w,\n      height: h\n    } = viewport;\n    const chart2 = getPerf().chart.data[element];\n    if (!chart2 || chart2.length === 0) {\n      return;\n    }\n    const padding = minimal ? 2 : 6;\n    const paddingTop = minimal ? 12 : 50;\n    let len = chart2.length;\n    for (let i = 0; i < len; i++) {\n      let id = (getPerf().chart.circularId + i + 1) % len;\n      if (chart2[id] !== void 0) {\n        if (chart2[id] > maxVal) {\n          maxVal = chart2[id] * factor;\n        }\n        dummyVec3.set(padding + i / (len - 1) * (w - padding * 2) - w / 2, Math.min(100, chart2[id]) * factor / 100 * (h - padding * 2 - paddingTop) - h / 2, 0);\n        dummyVec3.toArray(ref.attributes.position.array, i * 3);\n      }\n    }\n    ref.attributes.position.needsUpdate = true;\n  };\n  useFrame(function updateChartCurve(_ref2) {\n    let {\n      viewport\n    } = _ref2;\n    updatePoints(\"fps\", 1, fpsRef.current, viewport);\n    if (fpsMatRef.current) {\n      fpsMatRef.current.color.set(getPerf().overclockingFps ? colorsGraph(colorBlind).overClock.toString() : `rgb(${colorsGraph(colorBlind).fps.toString()})`);\n    }\n    updatePoints(\"gpu\", 5, gpuRef.current, viewport);\n    updatePoints(\"cpu\", 5, cpuRef.current, viewport);\n  });\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsxs(\"line\", {\n      onUpdate: self => {\n        self.updateMatrix();\n        matriceCount.value -= 1;\n        self.matrixWorld.copy(self.matrix);\n      },\n      children: [/* @__PURE__ */jsx(\"bufferGeometry\", {\n        ref: fpsRef,\n        children: /* @__PURE__ */jsx(\"bufferAttribute\", {\n          attach: \"attributes-position\",\n          count: chart.length,\n          array: curves.fps,\n          itemSize: 3,\n          usage: THREE.DynamicDrawUsage,\n          needsUpdate: true\n        })\n      }), /* @__PURE__ */jsx(\"lineBasicMaterial\", {\n        ref: fpsMatRef,\n        color: `rgb(${colorsGraph(colorBlind).fps.toString()})`,\n        transparent: true,\n        opacity: 0.5\n      })]\n    }), /* @__PURE__ */jsxs(\"line\", {\n      onUpdate: self => {\n        self.updateMatrix();\n        matriceCount.value -= 1;\n        self.matrixWorld.copy(self.matrix);\n      },\n      children: [/* @__PURE__ */jsx(\"bufferGeometry\", {\n        ref: gpuRef,\n        children: /* @__PURE__ */jsx(\"bufferAttribute\", {\n          attach: \"attributes-position\",\n          count: chart.length,\n          array: curves.gpu,\n          itemSize: 3,\n          usage: THREE.DynamicDrawUsage,\n          needsUpdate: true\n        })\n      }), /* @__PURE__ */jsx(\"lineBasicMaterial\", {\n        color: `rgb(${colorsGraph(colorBlind).gpu.toString()})`,\n        transparent: true,\n        opacity: 0.5\n      })]\n    }), /* @__PURE__ */jsxs(\"line\", {\n      onUpdate: self => {\n        self.updateMatrix();\n        matriceCount.value -= 1;\n        self.matrixWorld.copy(self.matrix);\n      },\n      children: [/* @__PURE__ */jsx(\"bufferGeometry\", {\n        ref: cpuRef,\n        children: /* @__PURE__ */jsx(\"bufferAttribute\", {\n          attach: \"attributes-position\",\n          count: chart.length,\n          array: curves.cpu,\n          itemSize: 3,\n          usage: THREE.DynamicDrawUsage,\n          needsUpdate: true\n        })\n      }), /* @__PURE__ */jsx(\"lineBasicMaterial\", {\n        color: `rgb(${colorsGraph(colorBlind).cpu.toString()})`,\n        transparent: true,\n        opacity: 0.5\n      })]\n    })]\n  });\n};\nconst ChartUI = _ref3 => {\n  let {\n    colorBlind,\n    chart,\n    customData,\n    matrixUpdate,\n    showGraph = true,\n    antialias = true,\n    minimal\n  } = _ref3;\n  const canvas = useRef(void 0);\n  const paused = usePerf(state => state.paused);\n  return /* @__PURE__ */jsxs(Graph, {\n    style: {\n      display: \"flex\",\n      position: \"absolute\",\n      height: `${minimal ? 37 : showGraph ? 100 : 60}px`,\n      minWidth: `${minimal ? \"100px\" : customData ? \"370px\" : \"310px\"}`\n    },\n    children: [/* @__PURE__ */jsx(Canvas, {\n      ref: canvas,\n      orthographic: true,\n      dpr: antialias ? [1, 2] : 1,\n      gl: {\n        antialias: true,\n        alpha: true,\n        stencil: false,\n        depth: false\n      },\n      onCreated: _ref4 => {\n        let {\n          scene\n        } = _ref4;\n        scene.traverse(obj => {\n          obj.matrixWorldAutoUpdate = false;\n          obj.matrixAutoUpdate = false;\n        });\n      },\n      flat: true,\n      style: {\n        marginBottom: `-42px`,\n        position: \"relative\",\n        pointerEvents: \"none\",\n        background: \"transparent !important\",\n        height: `${minimal ? 37 : showGraph ? 100 : 60}px`\n      },\n      children: !paused ? /* @__PURE__ */jsxs(Fragment, {\n        children: [/* @__PURE__ */jsx(Renderer, {}), /* @__PURE__ */jsx(TextsHighHZ, {\n          customData,\n          minimal,\n          matrixUpdate\n        }), showGraph && /* @__PURE__ */jsx(ChartCurve, {\n          colorBlind,\n          minimal,\n          chart\n        })]\n      }) : null\n    }), paused && /* @__PURE__ */jsxs(Graphpc, {\n      children: [/* @__PURE__ */jsx(PauseIcon, {}), \" PAUSED\"]\n    })]\n  });\n};\nconst Renderer = () => {\n  useFrame(function updateR3FPerf(_ref5) {\n    let {\n      gl,\n      scene,\n      camera\n    } = _ref5;\n    camera.updateMatrix();\n    matriceCount.value -= 1;\n    camera.matrixWorld.copy(camera.matrix);\n    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n    gl.render(scene, camera);\n    matriceWorldCount.value = 0;\n    matriceCount.value = 0;\n  }, Infinity);\n  return null;\n};\nexport { ChartUI };","map":{"version":3,"names":["ChartCurve","_ref","colorBlind","minimal","chart","length","hz","curves","useMemo","fps","Float32Array","cpu","gpu","fpsRef","useRef","fpsMatRef","gpuRef","cpuRef","dummyVec3","THREE","Vector3","updatePoints","element","factor","arguments","undefined","ref","viewport","maxVal","width","w","height","h","chart2","getPerf","data","padding","paddingTop","len","i","id","circularId","set","Math","min","toArray","attributes","position","array","needsUpdate","useFrame","updateChartCurve","_ref2","current","color","overclockingFps","colorsGraph","overClock","toString","jsxs","Fragment","children","onUpdate","self","updateMatrix","matriceCount","value","matrixWorld","copy","matrix","jsx","attach","count","itemSize","usage","DynamicDrawUsage","transparent","opacity","ChartUI","_ref3","customData","matrixUpdate","showGraph","antialias","canvas","paused","usePerf","state","Graph","style","display","minWidth","Canvas","orthographic","dpr","gl","alpha","stencil","depth","onCreated","_ref4","scene","traverse","obj","matrixWorldAutoUpdate","matrixAutoUpdate","flat","marginBottom","pointerEvents","background","Renderer","TextsHighHZ","Graphpc","PauseIcon","updateR3FPerf","_ref5","camera","matrixWorldInverse","invert","render","matriceWorldCount","Infinity"],"sources":["/home/joshua/Documents/proyectos/proyecto-integrador/reto_clase_4/node_modules/r3f-perf/src/components/Graph.tsx"],"sourcesContent":["import { FC, useMemo, useRef } from 'react';\nimport { matriceCount, matriceWorldCount } from './PerfHeadless';\nimport { Graph, Graphpc } from '../styles';\nimport { PauseIcon } from '@radix-ui/react-icons';\nimport { Canvas, useFrame, Viewport } from '@react-three/fiber';\nimport { getPerf, usePerf } from '..';\nimport { colorsGraph } from './Perf';\nimport * as THREE from 'three';\nimport { PerfUIProps } from '../typings';\nimport { TextsHighHZ } from './TextsHighHZ';\n\nexport interface graphData {\n  curve: THREE.SplineCurve;\n  maxVal: number;\n  element: string;\n}\n\n\nconst ChartCurve:FC<PerfUIProps> = ({colorBlind, minimal, chart= {length: 120, hz: 60}}) => {\n\n  const curves: any = useMemo(() => {\n    return {\n      fps: new Float32Array(chart.length * 3),\n      cpu: new Float32Array(chart.length * 3),\n      // mem: new Float32Array(chart.length * 3),\n      gpu: new Float32Array(chart.length * 3)\n    }\n  }, [chart])\n\n  const fpsRef= useRef<any>(null)\n  const fpsMatRef= useRef<any>(null)\n  const gpuRef= useRef<any>(null)\n  const cpuRef= useRef<any>(null)\n\n  const dummyVec3 = useMemo(() => new THREE.Vector3(0,0,0), [])\n  const updatePoints = (element: string, factor: number = 1, ref: any, viewport: Viewport) => {\n    let maxVal = 0;\n    const {width: w, height: h} = viewport\n    \n    const chart = getPerf().chart.data[element];\n    if (!chart || chart.length === 0) {\n      return\n    }\n    const padding = minimal ? 2 : 6\n    const paddingTop = minimal ? 12 : 50\n    let len = chart.length;\n    for (let i = 0; i < len; i++) {\n      let id = (getPerf().chart.circularId + i + 1) % len;\n      if (chart[id] !== undefined) {\n        if (chart[id] > maxVal) {\n          maxVal = chart[id] * factor;\n        }\n        dummyVec3.set(padding + i / (len - 1) * (w - padding * 2) - w / 2, (Math.min(100, chart[id]) * factor) / 100 * (h - padding * 2 - paddingTop) - h / 2, 0)\n        \n        dummyVec3.toArray(ref.attributes.position.array, i * 3)\n      }\n    }\n    \n    ref.attributes.position.needsUpdate = true;\n  };\n\n  // const [supportMemory] = useState(window.performance.memory)\n  useFrame(function updateChartCurve({viewport}) {\n    \n    updatePoints('fps', 1, fpsRef.current, viewport)\n    if (fpsMatRef.current) {\n      fpsMatRef.current.color.set(getPerf().overclockingFps ? colorsGraph(colorBlind).overClock.toString() : `rgb(${colorsGraph(colorBlind).fps.toString()})`)\n    }\n    updatePoints('gpu', 5, gpuRef.current, viewport)\n    // if (supportMemory) {\n      updatePoints('cpu', 5, cpuRef.current, viewport)\n    // }\n  })\n  return (\n    <>\n      {/* @ts-ignore */}\n      <line onUpdate={(self)=>{\n          self.updateMatrix()\n          matriceCount.value -= 1\n          self.matrixWorld.copy(self.matrix)\n        }}>\n        <bufferGeometry ref={fpsRef}>\n          <bufferAttribute\n              attach={'attributes-position'}\n              count={chart.length}\n              array={curves.fps}\n              itemSize={3}\n              usage={THREE.DynamicDrawUsage}\n              needsUpdate\n            />\n        </bufferGeometry>\n        <lineBasicMaterial ref={fpsMatRef} color={`rgb(${colorsGraph(colorBlind).fps.toString()})`} transparent opacity={0.5} />\n      </line>\n      {/* @ts-ignore */}\n      <line onUpdate={(self)=>{\n          self.updateMatrix()\n          matriceCount.value -= 1\n          self.matrixWorld.copy(self.matrix)\n        }}>\n        <bufferGeometry ref={gpuRef}>\n          <bufferAttribute\n              attach={'attributes-position'}\n              count={chart.length}\n              array={curves.gpu}\n              itemSize={3}\n              usage={THREE.DynamicDrawUsage}\n              needsUpdate\n            />\n        </bufferGeometry>\n        <lineBasicMaterial color={`rgb(${colorsGraph(colorBlind).gpu.toString()})`} transparent opacity={0.5} />\n      </line>\n      {/* @ts-ignore */}\n      <line onUpdate={(self)=>{\n          self.updateMatrix()\n          matriceCount.value -= 1\n          self.matrixWorld.copy(self.matrix)\n        }}>\n        <bufferGeometry ref={cpuRef}>\n          <bufferAttribute\n            attach={'attributes-position'}\n            count={chart.length}\n            array={curves.cpu}\n            itemSize={3}\n            usage={THREE.DynamicDrawUsage}\n            needsUpdate\n          />\n        </bufferGeometry>\n        <lineBasicMaterial color={`rgb(${colorsGraph(colorBlind).cpu.toString()})`} transparent opacity={0.5} />\n      </line>\n    </>\n  );\n};\n\nexport const ChartUI: FC<PerfUIProps> = ({\n  colorBlind,\n  chart,\n  customData,\n  matrixUpdate,\n  showGraph= true,\n  antialias= true,\n  minimal,\n}) => {\n  const canvas = useRef<any>(undefined);\n\n  const paused = usePerf((state) => state.paused);\n  return (\n    <Graph\n      style={{\n        display: 'flex',\n        position: 'absolute',\n        height: `${minimal ? 37 : showGraph ? 100 : 60 }px`,\n        minWidth: `${minimal ? '100px' : customData ? '370px' : '310px'}`\n      }}\n    >\n      <Canvas\n        ref={canvas}\n        orthographic\n        dpr={antialias ? [1,2] : 1}\n        gl={{\n          antialias: true,\n          alpha: true,\n          stencil: false,\n          depth: false,\n        }}\n        onCreated={({scene}) => {\n          scene.traverse((obj: THREE.Object3D)=>{\n            //@ts-ignore\n            obj.matrixWorldAutoUpdate=false\n            obj.matrixAutoUpdate=false\n          })\n        }}\n        flat={true}\n        style={{\n          marginBottom: `-42px`,\n          position: 'relative',\n          pointerEvents: 'none',\n          background: 'transparent !important',\n          height: `${minimal ? 37 : showGraph ? 100 : 60 }px`\n        }}\n      >\n        {!paused ? (\n          <>\n            <Renderer />\n            <TextsHighHZ customData={customData} minimal={minimal} matrixUpdate={matrixUpdate} />\n            {showGraph && <ChartCurve\n              colorBlind={colorBlind}\n              minimal={minimal}\n              chart={chart}\n            />}\n          </>\n        ) : null}\n      </Canvas>\n      {paused && (\n        <Graphpc>\n          <PauseIcon /> PAUSED\n        </Graphpc>\n      )}\n    </Graph>\n  );\n};\n\nconst Renderer = () =>{\n\n  useFrame(function updateR3FPerf({ gl, scene, camera }) {\n    camera.updateMatrix()\n    matriceCount.value -= 1\n    camera.matrixWorld.copy(camera.matrix)\n    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n    gl.render(scene,camera)\n    matriceWorldCount.value = 0\n    matriceCount.value = 0\n  }, Infinity)\n\n  \n  return null\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}